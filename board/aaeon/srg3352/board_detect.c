// SPDX-License-Identifier: GPL-2.0+
/*
 * Library to support early TI EVM EEPROM handling
 *
 * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
 *	Lokesh Vutla
 *	Steve Kipisz
 */

#include <common.h>
//#include <eeprom.h>
#include <asm/arch/hardware.h>
#include <asm/omap_common.h>
#include <dm/uclass.h>
//#include <env.h>
#include <i2c.h>
#include <mmc.h>
#include <stdio.h>
#include <linux/ctype.h>
#include <errno.h>
#include <malloc.h>

#include "board_detect.h"


__weak void gpi2c_init(void)
{
}

static int __maybe_unused srg5x_i2c_eeprom_get(int bus_addr, int dev_addr,
					    u32 header, u32 size, uint8_t *ep)
{
	u32 hdr_read;
	int rc;

	struct udevice *dev;
	struct udevice *bus;

	rc = uclass_get_device_by_seq(UCLASS_I2C, bus_addr, &bus);
	if (rc)
		return rc;
	rc = dm_i2c_probe(bus, dev_addr, 0, &dev);
	if (rc)
		return rc;

	/*
	 * Read the header first then only read the other contents.
	 */
	rc = i2c_set_chip_offset_len(dev, 1);
	if (rc)
		return rc;

	rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
	if (rc)
		return rc;

	/* Corrupted data??? */
	if (hdr_read != header) {
		rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
		/*
		 * read the eeprom header using i2c again, but use only a
		 * 1 byte address (some legacy boards need this..)
		 */
		if (rc) {
			rc =  i2c_set_chip_offset_len(dev, 1);
			if (rc)
				return rc;

			rc = dm_i2c_read(dev, 0, (uint8_t *)&hdr_read, 4);
		}
		if (rc)
			return rc;
	}
	if (hdr_read != header)
		return -1;

	rc = dm_i2c_read(dev, 0, ep, size);
	if (rc)
		return rc;

	return 0;
}

int __maybe_unused srg52_i2c_eeprom_get(int bus_addr, int dev_addr)
{
	int rc, size;
	struct srg52_eeprom_t *ep;
	struct srg52_eeprom_t buf;

	ep = SRG52_EEPROM_DATA;
#ifndef CONFIG_SPL_BUILD
	if (ep->magic == SRG52_EEPROM_HDR_MAGIC) {
		printf("was read eeprom\n");
		return 0; /* EEPROM has already been read */
	}
#endif
	/* Set to 0 all fields */
	memset(ep, 0, sizeof(*ep));
	memset(&buf, 0, sizeof(buf));
	ep->magic = SRG52_EEPROM_HDR_DEAD;

	rc = srg5x_i2c_eeprom_get(bus_addr, dev_addr, SRG52_EEPROM_HDR_MAGIC,
					sizeof(buf), (uint8_t *)&buf);
	if (rc)
		return rc;

	ep->magic = buf.magic;
	memcpy(ep->rev, buf.rev, 2);
	strlcpy(ep->bname, buf.bname, SRG52_EEPROM_HDR_BRD_LEN + 1);
	strlcpy(ep->serial, buf.serial, SRG52_EEPROM_HDR_SN_LEN + 1);
	strlcpy(ep->manufacturer, buf.manufacturer, SRG52_EEPROM_HDR_SN_LEN + 1);
	size = ((int)(&ep->crc16) - (int)(&ep->macEth0));
	memcpy(&ep->macEth0, &buf.macEth0, size);
	return 0;
}

int __maybe_unused srg52_i2c_eeprom_set(const char *name, const u16 rev)
{
	struct srg52_eeprom_t *ep;
	u16 hdr_rev = SRG52_EEPROM_HDR_REV;

	if (!name || !rev)
		return -1;

	ep = SRG52_EEPROM_DATA;
	if (ep->magic == SRG52_EEPROM_HDR_MAGIC)
		goto already_set;

	/* Set to 0 all fields */
	memset(ep, 0, sizeof(*ep));
	strncpy((char *)ep->bname, name, SRG52_EEPROM_HDR_BRD_LEN);
	/* Some dummy serial number to identify the platform */
	strncpy((char *)ep->serial, "00000000000000000", SRG52_EEPROM_HDR_SN_LEN);
	strncpy((char *)ep->manufacturer, "AAEON TECHNOLOGY INC.", SRG52_EEPROM_HDR_MNF_LEN);
	/* Mark it with a valid magic header */
	ep->magic = SRG52_EEPROM_HDR_MAGIC;
	memcpy(&ep->rev, &hdr_rev, SRG52_EEPROM_HDR_REV_LEN);


already_set:
	return 0;
}

void __maybe_unused
board_srg52_get_eth_mac_addr(int index,
			  u8 mac_addr[SRG52_EEPROM_HDR_ETH_ALEN])
{

	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;

	if (ep->magic != SRG52_EEPROM_HDR_MAGIC) {
		memset(mac_addr, 0, SRG52_EEPROM_HDR_ETH_ALEN);
		return;
	}

	switch(index) {
	case 0:
		memcpy(mac_addr, ep->macEth0, SRG52_EEPROM_HDR_ETH_ALEN);
		break;
	case 1:
		memcpy(mac_addr, ep->macEth1, SRG52_EEPROM_HDR_ETH_ALEN);
		break;
	case 2:
		memcpy(mac_addr, ep->macBt, SRG52_EEPROM_HDR_ETH_ALEN);
		break;
	case 3:
		memcpy(mac_addr, ep->macWlan, SRG52_EEPROM_HDR_ETH_ALEN);
		break;
	default:
		memset(mac_addr, 0, SRG52_EEPROM_HDR_ETH_ALEN);
		break;
	}
}

#include "config.h"
#include "generated/autoconf.h"
#include "generated/timestamp_autogenerated.h"
#include "generated/version_autogenerated.h"

#if !defined(CONFIG_SPL_BUILD)

void __maybe_unused set_project_info_env(void)
{
    char bl_version[30];
    char bl_date[30];

    snprintf(bl_version, sizeof(bl_version), "%s", PLAIN_VERSION);
    snprintf(bl_date, sizeof(bl_date), "%s", U_BOOT_DMI_DATE);

    env_set("bl_vendor", CONFIG_SMBIOS_MANUFACTURER);
    env_set("bl_version", bl_version);
    env_set("bl_date", bl_date);

    env_set("product_name", CONFIG_SMBIOS_PRODUCT_NAME);
}

bool board_srg52_get_common(char *target, char *buff, int len)
{
	char temp[SRG52_EEPROM_HDR_BRD_LEN + 1] = { 0 };

	for (int i=0; i < len; i++) {
		if (isprint(target[i])) {
			temp[i] = target[i];
		}
		else if (target[i] == '\0') {
			len = i;
			break;
		}
		else
			return false;
	}
	memcpy(buff, temp, len + 1);
	return true;
}

bool board_srg52_get_boardname(char *buff)
{
	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;
	if (buff == NULL || (!board_srg52_was_eeprom_read()))
		return false;

	return board_srg52_get_common(ep->bname, buff, SRG52_EEPROM_HDR_BRD_LEN);
}

bool board_srg52_get_serial(char *buff) {
	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;
	if (buff == NULL || (!board_srg52_was_eeprom_read()))
		return false;

	return board_srg52_get_common(ep->serial, buff, SRG52_EEPROM_HDR_SN_LEN);
}

bool board_srg52_get_manufacturer(char *buff) {
	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;
	if (buff == NULL || (!board_srg52_was_eeprom_read()))
		return false;

	return board_srg52_get_common(ep->manufacturer, buff, SRG52_EEPROM_HDR_MNF_LEN);
}

void __maybe_unused set_board_info_env(char *name)
{
	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;
	char *unknown = "unknown";
	char *defname = "SRG-3352C";
	char buff[36] = { 0 };
	bool bEE = board_srg52_was_eeprom_read();

	if (bEE && board_srg52_get_boardname(buff))
		env_set("board_name", buff);
	else if (name)
		env_set("board_name", name);
	else
		env_set("board_name", defname);

	if (bEE && board_srg52_get_manufacturer(buff))
		env_set("board_vendor", buff);

	if (bEE && ep->hwRev) {
		snprintf(buff, 31, "%c%c", ep->hwRev[0], ep->hwRev[1]);
		env_set("board_rev", buff);
	}
	else
		env_set("board_rev", unknown);

	if (bEE && board_srg52_get_serial(buff)) {
		env_set("board_serial", buff);
	}
	else
		env_set("board_serial", unknown);

	if (bEE) {
		snprintf(buff, 31, "%d", ep->bootCount);
		env_set("boot_count", buff);
	}

	if (bEE) {
		u8 mac_addr[6];
		for (int i =0; i < 2; i++) {
			board_srg52_get_eth_mac_addr(i, mac_addr);
			if (is_valid_ethaddr(mac_addr)) {
				eth_env_set_enetaddr_by_index("eth", i, mac_addr);
			}
		}
	}
}
#endif

bool __maybe_unused board_srg52_was_eeprom_read(void)
{
	struct srg52_eeprom_t *ep = SRG52_EEPROM_DATA;

	if (ep->magic == SRG52_EEPROM_HDR_MAGIC)
		return true;
	else
		return false;
}
